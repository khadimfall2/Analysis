---
title: "TP1"
output: html_document
date: "2024-11-12"
---

``````{r cars}
euro_data <- read.csv("data/euro.csv", header = TRUE, sep = ";")


# Normalisation des données (Min-Max Scaling)
euro_data_normalized <- as.data.frame(lapply(euro_data[, -1], function(x) {
  (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
}))
```


``````{r cars}
if (!require(ggplot2)) install.packages("ggplot2")
if (!require(reshape2)) install.packages("reshape2")

library(ggplot2)
library(reshape2)

```


## R Markdown


```{r cars}

# Supprimer la première colonne (noms des pays)
euro_data <- euro_data[, -1]

# Convertir les colonnes en numériques si nécessaire
euro_data <- data.frame(lapply(euro_data, function(x) as.numeric(as.character(x))))

# Créer une boîte à moustaches pour chaque colonne
for (col_name in colnames(euro_data)) {
  # Tracer la boîte à moustaches pour la colonne en cours
  boxplot(euro_data[[col_name]],
          main = paste("Boîte à moustaches pour", col_name),
          ylab = col_name,
          col = "lightblue",
          border = "darkblue")
}
```
```

## Including Plots

You can also embed plots, for example:
```
```{r pressure, echo=FALSE}
# Centrer les données : soustraire la moyenne de chaque colonne
euro_data_centered <- scale(euro_data, center = TRUE, scale = FALSE)

# Calculer la matrice de variance-covariance
n <- nrow(euro_data)  # Nombre d'observations
V <- (t(euro_data_centered) %*% euro_data_centered) / (n - 1)

# Afficher la matrice
print("Matrice de variance-covariance :")
print(V)
```


```{r pressure, echo=FALSE}
# Arrondir les valeurs de la matrice à 2 décimales
print("Matrice de variance-covariance (arrondie) :")
round(V, 2)
```


```{r pressure, echo=FALSE}
# Si le package knitr n'est pas installé, installe-le
if (!require(knitr)) install.packages("knitr")
```


```{r pressure, echo=FALSE}
# Formatage de la matrice
knitr::kable(round(V, 2),
```


```{r pressure, echo=FALSE}
# Installer ggplot2 si nécessaire
# Convertir la matrice en format long pour ggplot2
V_melted <- melt(round(V, 2))

# Heatmap pour visualiser la matrice
ggplot(V_melted, aes(Var1, Var2, fill = value)) +
  geom_tile() +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(min(V_melted$value), max(V_melted$value))) +
  theme_minimal() +
  labs(title = "Heatmap de la matrice de variance-covariance", 
       x = "Variables", 
       y = "Variables", 
       fill = "Valeur") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 


```


install.packages("corrplot")

library("corrplot")
corrplot(cor(euro_data))


```{r pressure, echo=FALSE}

#Matrice de correlation linéaire, ne marche pas sur les pc a la fac

corr_lin = cor(euro_data),

print(corr_lin),

install.packages("corrplot"),
library(corrplot),

corrplot(corr_lin)
```

# PRComp

```{r}

# Ou remplacer les NA par la moyenne de chaque colonne
euro_data_replace_na <- apply(euro_data, 2, function(x) ifelse(is.na(x), mean(x, na.rm = TRUE), x))


res = prcomp(euro_data_replace_na, scale=TRUE, center=TRUE)

res$rotation <- -1*res$rotation

res$x <- -1*res$x

#display the first six scores
head(res$x)

biplot(res, scale = 0)
```



```{r}
coord = res$x
#récupérer nom des pays 
tmp <- read.csv("data/euro.csv", header = TRUE, sep = ";")
rownames(coord) <- tmp[, 1]

# Créez le graphique
plot(coord[, 1], coord[, 2], 
     xlab = "PC1", ylab = "PC2", 
     main = "Premier plan factoriel (PC1 vs PC2)", 
     pch = 20, col = "blue")

# Ajouter les noms des pays
text(coord[, 1], coord[, 2], labels = rownames(coord), pos = 4, cex = 0.8)

```