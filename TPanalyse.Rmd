---
title: "Analyse des données européennes"
author: "FALL"
date: "`r Sys.Date()`"
output: 
  pdf_document:
    number_sections: true
    toc: true
    
---
# Contexte général

Les données analysées dans ce projet concernent différents indicateurs socio-économiques et environnementaux pour un ensemble de pays européens. Ces indicateurs offrent une vision globale de divers aspects comme la démographie, l'économie, l'énergie, l'emploi et l'environnement. Les analyses visent à explorer les structures sous-jacentes et les relations entre ces variables, ainsi qu'à regrouper les pays selon des caractéristiques communes.


*Description des variables*

Les données contiennent 16 variables descriptives, reflétant des dimensions clés : 

    Population au 1er janvier : Nombre absolu d'habitants.
    Population jeune (15-29 ans) : Pourcentage de jeunes dans la population totale.
    Premières demandes d'asile : Nombre absolu de demandes.
    Écart de rémunération entre les sexes : Pourcentage de différence de salaire horaire brut moyen entre hommes et femmes.
    Salaire minimum : Montant en euros par mois.
    Décrocheurs scolaires précoces : Pourcentage de la population âgée de 18 à 24 ans quittant prématurément le système scolaire.
    Taux d'inflation : Variation en pourcentage par rapport à l'année précédente.
    Taux de chômage : Pourcentage de la population active âgée de 15 à 74 ans.
    Taux de chômage des jeunes : Pourcentage de la population active de moins de 25 ans.
    PIB par habitant : Produit intérieur brut en euros par habitant.
    Dette brute du gouvernement : Pourcentage de la dette brute par rapport au PIB.
    Émissions de gaz à effet de serre : Quantité moyenne en tonnes par habitant.
    Énergies renouvelables : Pourcentage dans la consommation finale brute d'énergie.
    Prix de l'électricité : Montant en euros par MWh, incluant les taxes.
    Dépendance aux importations d'énergie : Pourcentage de dépendance à l'énergie importée.
    Taux de risque de pauvreté ou d'exclusion sociale : Pourcentage de la population à risque de pauvreté ou d'exclusion sociale.

L’objectif de cette analyse est d’explorer et de réduire la dimensionnalité des données grâce à une analyse en composantes principales (ACP), puis de grouper les pays selon leurs caractéristiques à l’aide de méthodes de classification. L’ACP permet de visualiser les similitudes entre pays et d’identifier les variables les plus importantes. Les méthodes de classification, notamment la classification ascendante hiérarchique (CAH) et l’algorithme des centres mobiles (k-means), permettent d’interpréter les regroupements obtenus. Les résultats des classifications seront comparés afin de comprendre les proximités entre pays et leur cohérence.

Pour la préparation des données, une normalisation a été appliquée pour rendre les variables comparables. L’analyse inclut la création de matrices de dissimilarité, l’utilisation de la décomposition en valeurs propres pour l’ACP, et l’application des méthodes de classification sur les données normalisées. Les regroupements obtenus seront interprétés à travers l’étude des centres de gravité, des inerties et des plans factoriels. Enfin, une attention particulière sera portée à l’analyse des proximités des pays dans des zones spécifiques de l’espace factoriel, afin de mieux comprendre les similarités entre pays.








```{r setup, message=FALSE, warning=FALSE}
# Vérification et chargement des bibliothèques nécessaires
if (!require(ggplot2)) install.packages("ggplot2", dependencies = TRUE)
library(ggplot2)

# Chargement de TinyTeX si nécessaire (une seule fois)
if (!tinytex::is_tinytex()) {
  tinytex::install_tinytex()
}
```


```{r}
euro_data <- read.csv("data/euro.csv", header = TRUE, sep = ";")

# Normalisation des données (Min-Max Scaling)
euro_data_normalized <- as.data.frame(lapply(euro_data[, -1], function(x) {
  (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
}))
```

*Diagrammes à mmoustache*

La distribution de la variable Population montre une grande variabilité entre les pays européens. Certains pays, comme l'Allemagne (84,3 millions), la France (68,1 millions) et l'Italie (58,9 millions), présentent des populations nettement supérieures à la majorité. Ces valeurs extrêmes contrastent avec des pays de petite taille comme Malte (0,54 million) et Chypre (0,92 million). La médiane, relativement basse, indique que la plupart des pays européens ont des populations bien inférieures à ces valeurs élevées.

Quant à la variable Youth Population (pourcentage de jeunes âgés de 15 à 29 ans), elle présente une répartition beaucoup plus homogène. Les pourcentages varient de 13,2 % (Bulgarie) à 21,0 % (Islande), sans aucune valeur aberrante. La médiane est bien centrée, reflétant une répartition équilibrée entre les pays. On observe que les pays nordiques, comme l’Islande (21,0 %) et la Norvège (18,7 %), possèdent des proportions relativement élevées de jeunes, tandis que des pays comme la Bulgarie se situent à l'extrémité inférieure de cette répartition.


```{r}
# Supprimer la première colonne si elle contient des noms (optionnel)
euro_data <- euro_data[, -1]

# Sélectionner les colonnes pour les diagrammes (par groupe de 2)
selected_columns <- colnames(euro_data)[1:2]  # Modifier pour sélectionner un autre groupe de colonnes (par ex. 5:6)

# Ajuster les marges et l'espacement
par(mfrow = c(1, 2),  # Deux graphiques côte à côte
    oma = c(2, 2, 2, 2),  # Marges extérieures : bas, gauche, haut, droite
    mar = c(5, 5, 4, 2))  # Marges intérieures : bas, gauche, haut, droite

# Boucle pour tracer les boîtes à moustaches
for (col_name in selected_columns) {
  boxplot(euro_data[[col_name]],
          main = paste("Boîte à moustaches\n", col_name),  # Titre sur deux lignes
          ylab = col_name,
          col = "lightblue",
          border = "darkblue",
          cex.main = 1.1,  # Taille du titre
          cex.lab = 1.1,  # Taille des étiquettes
          cex.axis = 0.9)  # Taille des axes
}

# Réinitialiser les paramètres
par(mfrow = c(1, 1))  




```

La distribution de la variable First Time Asylum Applicants (premières demandes d'asile) montre une forte asymétrie, avec plusieurs valeurs extrêmes très élevées. Ces valeurs, représentées par des points au-dessus des moustaches, indiquent que quelques pays reçoivent un nombre disproportionné de premières demandes d'asile par rapport à la majorité. La médiane est très basse, ce qui reflète que la plupart des pays ont un nombre relativement faible de demandes.

La variable Gender Pay Gap (écart de rémunération entre les sexes) présente une distribution symétrique et homogène. La médiane est bien centrée, et la boîte à moustaches indique que les valeurs sont concentrées dans une plage relativement étroite. Aucun outlier n’est visible, ce qui suggère que les écarts salariaux entre les sexes sont globalement similaires parmi les pays analysés.
Interprétation

Les données brutes confirment les observations issues des diagrammes à moustaches. Concernant les First Time Asylum Applicants, on observe de fortes valeurs pour des pays comme l'Allemagne (0,32 million) et la France (0,14 million), qui reçoivent un grand nombre de demandes. À l'inverse, des pays comme la Slovaquie (0,0003 million) et la Hongrie (0,00003 million) présentent des valeurs bien en dessous de la moyenne, reflétant une disparité importante.

Pour la variable Gender Pay Gap, les données confirment l'homogénéité observée. Toutefois, on peut noter des différences significatives entre certains pays. Par exemple, l'Autriche (18,4) et la Suisse (17,9) affichent des valeurs élevées, tandis que le Luxembourg présente une valeur négative (-0,7), indiquant une situation inverse inhabituelle.

```{r}
# Sélectionner les colonnes pour les diagrammes (par groupe de 2)
selected_columns <- colnames(euro_data)[3:4]  # Modifier pour sélectionner un autre groupe de colonnes (par ex. 5:6)

# Ajuster les marges et l'espacement
par(mfrow = c(1, 2),  # Deux graphiques côte à côte
    oma = c(2, 2, 2, 2),  # Marges extérieures : bas, gauche, haut, droite
    mar = c(5, 5, 4, 2))  # Marges intérieures : bas, gauche, haut, droite

# Boucle pour tracer les boîtes à moustaches
for (col_name in selected_columns) {
  boxplot(euro_data[[col_name]],
          main = paste("Boîte à moustaches\n", col_name),  # Titre sur deux lignes
          ylab = col_name,
          col = "lightblue",
          border = "darkblue",
          cex.main = 1.2,  # Taille du titre
          cex.lab = 1.1,  # Taille des étiquettes
          cex.axis = 0.9)  # Taille des axes
}

# Réinitialiser les paramètres
par(mfrow = c(1, 1))  


```
La distribution de la variable Minimum Wage (salaire minimum) montre une dispersion modérée avec quelques valeurs basses qui se démarquent, visibles sous forme de moustaches allongées. La médiane est située dans la moitié inférieure de la boîte, indiquant qu'une majorité des pays ont un salaire minimum inférieur à la moyenne globale. Aucune valeur aberrante significative n'est visible.


La variable People at Risk of Poverty or Exclusion (personnes à risque de pauvreté ou d'exclusion sociale) présente une distribution assez homogène. La médiane est centrée, ce qui indique une répartition symétrique des données entre les différents pays. La boîte montre que la majorité des pays ont des valeurs proches les unes des autres, reflétant une cohérence entre les nations sur cet indicateur.

```{r}
# Sélectionner les colonnes pour les diagrammes (par groupe de 2)
selected_columns <- colnames(euro_data)[5:6]  # Modifier pour sélectionner un autre groupe de colonnes (par ex. 5:6)

# Ajuster les marges et l'espacement
par(mfrow = c(1, 2),  # Deux graphiques côte à côte
    oma = c(2, 2, 2, 2),  # Marges extérieures : bas, gauche, haut, droite
    mar = c(5, 5, 4, 2))  # Marges intérieures : bas, gauche, haut, droite

# Boucle pour tracer les boîtes à moustaches
for (col_name in selected_columns) {
  boxplot(euro_data[[col_name]],
          main = paste("Boîte à moustaches\n", col_name),  # Titre sur deux lignes
          ylab = col_name,
          col = "lightblue",
          border = "darkblue",
          cex.main = 1.2,  # Taille du titre
          cex.lab = 1.1,  # Taille des étiquettes
          cex.axis = 0.9)  # Taille des axes
}

# Réinitialiser les paramètres
par(mfrow = c(1, 1))  


```
La distribution de la variable Early School Leavers (décrocheurs scolaires précoces) montre une répartition assez homogène, sans valeurs aberrantes significatives. La médiane est centrée dans la boîte, indiquant une répartition équilibrée entre les pays. La plupart des pays ont des taux de décrochage scolaire compris entre les moustaches, avec peu de variabilité.


La variable Inflation Rate (taux d’inflation) présente une valeur aberrante, visible sous forme de point au-dessus des moustaches. Cela indique qu'un ou quelques pays ont un taux d’inflation nettement supérieur à la majorité. La boîte est asymétrique, suggérant une distribution légèrement biaisée vers les valeurs inférieures.

```{r}
# Sélectionner les colonnes pour les diagrammes (par groupe de 2)
selected_columns <- colnames(euro_data)[7:8]  # Modifier pour sélectionner un autre groupe de colonnes (par ex. 5:6)

# Ajuster les marges et l'espacement
par(mfrow = c(1, 2),  # Deux graphiques côte à côte
    oma = c(2, 2, 2, 2),  # Marges extérieures : bas, gauche, haut, droite
    mar = c(5, 5, 4, 2))  # Marges intérieures : bas, gauche, haut, droite

# Boucle pour tracer les boîtes à moustaches
for (col_name in selected_columns) {
  boxplot(euro_data[[col_name]],
          main = paste("Boîte à moustaches\n", col_name),  # Titre sur deux lignes
          ylab = col_name,
          col = "lightblue",
          border = "darkblue",
          cex.main = 1.2,  # Taille du titre
          cex.lab = 1.1,  # Taille des étiquettes
          cex.axis = 0.9)  # Taille des axes
}

# Réinitialiser les paramètres
#par(mfrow = c(2, 1))  


```
La variable Unemployment Rate (taux de chômage) montre une distribution globalement homogène, bien que deux valeurs aberrantes soient visibles au-dessus des moustaches. Ces valeurs indiquent que certains pays connaissent un taux de chômage nettement plus élevé que la moyenne. La médiane, légèrement au-dessus du centre de la boîte, suggère une légère asymétrie vers des valeurs inférieures.

Pour la variable Youth Unemployment Rate (taux de chômage des jeunes), la distribution est plus dispersée, sans valeurs aberrantes. La boîte et les moustaches reflètent une variabilité importante entre les pays, traduisant des disparités régionales marquées. La médiane, située un peu en dessous du centre, indique une distribution légèrement asymétrique.
```{r}
# Sélectionner les colonnes pour les diagrammes (par groupe de 2)
selected_columns <- colnames(euro_data)[9:10]  # Modifier pour sélectionner un autre groupe de colonnes (par ex. 5:6)

# Ajuster les marges et l'espacement
par(mfrow = c(1, 2),  # Deux graphiques côte à côte
    oma = c(2, 2, 2, 2),  # Marges extérieures : bas, gauche, haut, droite
    mar = c(5, 5, 4, 2))  # Marges intérieures : bas, gauche, haut, droite

# Boucle pour tracer les boîtes à moustaches
for (col_name in selected_columns) {
  boxplot(euro_data[[col_name]],
          main = paste("Boîte à moustaches\n", col_name),  # Titre sur deux lignes
          ylab = col_name,
          col = "lightblue",
          border = "darkblue",
          cex.main = 1.2,  # Taille du titre
          cex.lab = 1.1,  # Taille des étiquettes
          cex.axis = 0.9)  # Taille des axes
}


```
La variable GDP per Capita (PIB par habitant) présente une distribution avec une valeur aberrante notable correspondant à un pays dont le PIB par habitant est extrêmement élevé par rapport aux autres. La majorité des pays se situent dans une plage relativement restreinte, comme le montre la boîte. La médiane est bien centrée, indiquant une répartition relativement symétrique parmi les pays exclus des valeurs aberrantes.


La variable Government Gross Debt (dette brute du gouvernement en pourcentage du PIB) montre deux valeurs aberrantes au-dessus des moustaches, indiquant que certains pays ont des niveaux de dette exceptionnellement élevés. La boîte indique une distribution concentrée pour la majorité des pays avec une médiane légèrement en dessous du centre, suggérant une légère asymétrie vers les valeurs plus faibles.

```{r}
# Sélectionner les colonnes pour les diagrammes (par groupe de 2)
selected_columns <- colnames(euro_data)[11:12]  # Modifier pour sélectionner un autre groupe de colonnes (par ex. 5:6)

# Ajuster les marges et l'espacement
par(mfrow = c(1, 2),  # Deux graphiques côte à côte
    oma = c(2, 2, 2, 2),  # Marges extérieures : bas, gauche, haut, droite
    mar = c(5, 5, 4, 2))  # Marges intérieures : bas, gauche, haut, droite

# Boucle pour tracer les boîtes à moustaches
for (col_name in selected_columns) {
  boxplot(euro_data[[col_name]],
          main = paste("Boîte à moustaches\n", col_name),  # Titre sur deux lignes
          ylab = col_name,
          col = "lightblue",
          border = "darkblue",
          cex.main = 1.2,  # Taille du titre
          cex.lab = 1.1,  # Taille des étiquettes
          cex.axis = 0.9)  # Taille des axes
}

# Réinitialiser les paramètres
par(mfrow = c(1, 1))  

```
La variable Greenhouse Gas Emissions (émissions de gaz à effet de serre en tonnes par habitant) présente deux valeurs aberrantes correspondant à des pays avec des émissions particulièrement élevées. La médiane est légèrement inférieure au centre de la boîte, indiquant une légère asymétrie vers les valeurs plus faibles. Cela suggère que la majorité des pays ont des émissions modérées, tandis qu'un petit nombre a des émissions bien au-dessus de la moyenne.


La variable Renewable Energy (part des énergies renouvelables dans la consommation énergétique) montre également deux valeurs aberrantes pour des pays ayant une part particulièrement élevée d'énergies renouvelables. La distribution est asymétrique, avec une majorité des pays ayant des parts plus faibles en énergies renouvelables. La médiane est proche du bas de la boîte, indiquant une concentration de valeurs relativement faibles pour la plupart des 

```{r}
# Sélectionner les colonnes pour les diagrammes (par groupe de 2)
selected_columns <- colnames(euro_data)[13:14]  # Modifier pour sélectionner un autre groupe de colonnes (par ex. 5:6)

# Ajuster les marges et l'espacement
par(mfrow = c(1, 2),  # Deux graphiques côte à côte
    oma = c(2, 2, 2, 2),  # Marges extérieures : bas, gauche, haut, droite
    mar = c(5, 5, 4, 2))  # Marges intérieures : bas, gauche, haut, droite

# Boucle pour tracer les boîtes à moustaches
for (col_name in selected_columns) {
  boxplot(euro_data[[col_name]],
          main = paste("Boîte à moustaches\n", col_name),  # Titre sur deux lignes
          ylab = col_name,
          col = "lightblue",
          border = "darkblue",
          cex.main = 1.2,  # Taille du titre
          cex.lab = 1.1,  # Taille des étiquettes
          cex.axis = 0.9)  # Taille des axes
}

# Réinitialiser les paramètres
par(mfrow = c(1, 1))  

```
La variable Electricity Prices (prix de l'électricité en euros par MWh, taxes incluses) montre une distribution relativement homogène, sans valeurs aberrantes visibles. La boîte à moustaches illustre une concentration modérée autour de la médiane, indiquant que les prix sont globalement similaires entre les pays européens. Cependant, la largeur de la boîte et des moustaches traduit une certaine variabilité, reflétant des écarts notables pour certains pays. Par exemple, des pays comme l'Allemagne et le Danemark ont historiquement des prix de l'électricité plus élevés.

La variable Energy Imports Dependency (dépendance aux importations d'énergie, exprimée en pourcentage) présente une dispersion importante entre les pays. La médiane, située dans le haut de la boîte, indique que la majorité des pays ont une dépendance modérée à élevée. La variabilité marquée, visible à travers les moustaches longues, reflète des écarts significatifs : certains pays, comme Malte (99,0 %) et Chypre (92,0 %), affichent une forte dépendance énergétique, tandis que d'autres, comme l'Islande (15,2 %) et la Norvège (15,2 %), montrent une indépendance énergétique notable. Cette disparité est probablement liée à la disponibilité des ressources énergétiques, à leur gestion efficace et à l'intégration des énergies renouvelables.

```{r}
# Sélectionner les colonnes pour les diagrammes (par groupe de 2)
selected_columns <- colnames(euro_data)[15:16]  # Modifier pour sélectionner un autre groupe de colonnes (par ex. 5:6)

# Ajuster les marges et l'espacement
par(mfrow = c(1, 2),  # Deux graphiques côte à côte
    oma = c(2, 2, 2, 2),  # Marges extérieures : bas, gauche, haut, droite
    mar = c(5, 5, 4, 2))  # Marges intérieures : bas, gauche, haut, droite

# Boucle pour tracer les boîtes à moustaches
for (col_name in selected_columns) {
  boxplot(euro_data[[col_name]],
          main = paste("Boîte à moustaches\n", col_name),  # Titre sur deux lignes
          ylab = col_name,
          col = "lightblue",
          border = "darkblue",
          cex.main = 1.2,  # Taille du titre
          cex.lab = 1.1,  # Taille des étiquettes
          cex.axis = 0.9)  # Taille des axes
}

# Réinitialiser les paramètres

```


```{r}
# Centrer les données : soustraire la moyenne de chaque colonne

" Question 3 "
euro_data_centered <- scale(euro_data, center = TRUE, scale = FALSE)

# Calculer la matrice de variance-covariance
n <- nrow(euro_data)  # Nombre d'observations
V <- (t(euro_data_centered) %*% euro_data_centered) / (n - 1)

# Afficher la matrice
print("Matrice de variance-covariance :")
print(V)
```


```{r}
#  Question 3 suite 
V_rounded <- round(V, 2)
# Étape 3 : Créer la heatmap
heatmap(as.matrix(V_rounded), 
        main = "Heatmap de la matrice de variance-covariance",
        Colv = NA, Rowv = NA,  # Désactive le clustering
        scale = "none",  # Pas de normalisation supplémentaire
        col = heat.colors(10),  # Palette de couleurs
        margins = c(10, 10))  # Marges pour la lisibilité

```


```{r}
# Arrondir les valeurs de la matrice à 2 décimales
print("Matrice de variance-covariance (arrondie) :")
round(V, 2)
```
```{r}

```








```{r}
# Ajouter les noms de lignes et colonnes pour un tableau clair
rownames(V) <- colnames(V) <- colnames(euro_data)

# Afficher sous forme de tableau avec arrondi
print(round(V, 2))
```


```{r}
#  Question 3 suite 
V_rounded <- round(V, 2)

# Étape 3 : Créer la heatmap
heatmap(as.matrix(V_rounded), 
        main = "Heatmap de la matrice de variance-covariance",
        Colv = NA, Rowv = NA,  # Désactive le clustering
        scale = "none",  # Pas de normalisation supplémentaire
        col = heat.colors(10),  # Palette de couleurs
        margins = c(10, 10))  # Marges pour la lisibilité


```





```{r}
# Question 4 améliorée 
# Transformer la matrice de corrélation en format long
# Calculer la matrice de corrélation
correlation_matrix <- cor(euro_data, use = "complete.obs")

# Afficher un aperçu de la matrice
print("Matrice de corrélation (arrondie) :")
round(correlation_matrix, 2)


```


```{r}
# Transformer la matrice de corrélation en format long
correlation_long <- reshape2::melt(round(correlation_matrix, 2))
```


```{r}
# Heatmap de la matrice de corrélation
ggplot(correlation_long, aes(Var1, Var2, fill = value)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1, 1), 
                       name = "Corrélation") +
  theme_minimal() +
  labs(title = "Heatmap de la matrice de corrélation",
       x = "Variables",
       y = "Variables") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


```{r}
head(euro_data)
```


```{r}
# Question 5 
# Remplacer les NA par la moyenne
euro_data_replace_na <- apply(euro_data, 2, function(x) ifelse(is.na(x), mean(x, na.rm = TRUE), x))

# Calculer les composantes principales
res <- prcomp(euro_data_replace_na, scale = TRUE, center = TRUE)

# Vérification de l'orthogonalité et des normes
orthogonality_check <- t(res$rotation) %*% res$rotation
cat("Produit scalaire des vecteurs propres (orthogonalité) :\n")
print(round(orthogonality_check, 2))

norms <- apply(res$rotation, 2, function(col) sqrt(sum(col^2)))
cat("Normes des vecteurs propres (1 attendu) :\n")
print(round(norms, 2))

# Afficher les premières coordonnées dans la nouvelle base
cat("Premières coordonnées des observations :\n")
head(res$x)

# Biplot pour visualiser les résultats
biplot(res, scale = 0)
```


```{r}
# Question 6 
# Étape 1 : Calculer les composantes principales (si non déjà fait)
euro_data_replace_na <- apply(euro_data, 2, function(x) ifelse(is.na(x), mean(x, na.rm = TRUE), x))
res <- prcomp(euro_data_replace_na, scale = TRUE, center = TRUE)

# Étape 2 : Récupérer les coordonnées dans la nouvelle base
```


```{r}
coord <- res$x

# Étape 3 : Ajouter les noms des pays comme noms de lignes
tmp <- read.csv("data/euro.csv", header = TRUE, sep = ";")
rownames(coord) <- tmp[, 1]

# Étape 4 : Créer le graphique du premier plan factoriel
plot(coord[, 1], coord[, 2], 
     xlab = "PC1", ylab = "PC2", 
     main = "Premier plan factoriel (PC1 vs PC2)", 
     pch = 20, col = "blue")

# Étape 5 : Ajouter les noms des pays sur le graphique
text(coord[, 1], coord[, 2], labels = rownames(coord), pos = 4, cex = 0.6)
```


```{r}
# Question 7 
# Extraire les variances (valeurs propres)
variances <- res$sdev^2

# Calculer le pourcentage de variance expliquée
pourcentages <- variances / sum(variances) * 100

# Calculer la variance expliquée cumulée
cumul <- cumsum(pourcentages)

# Afficher les informations pour contrôle
cat("Valeurs propres :\n")
print(round(variances, 2))

cat("\nPourcentages de variances expliquées :\n")
print(round(pourcentages, 2))

cat("\nVariance expliquée cumulée :\n")
print(round(cumul, 2))
```


```{r}
# Question 7 
# Créer un graphique combiné
plot(pourcentages, type = "b", pch = 19, col = "blue",
     xlab = "Numéro de la composante principale",
     ylab = "Pourcentage de variance expliquée",
     main = "Ébouli des valeurs propres")
lines(cumul, type = "b", pch = 19, col = "red")  # Ajouter la variance cumulée

# Ajouter une légende
legend("topright", legend = c("Variance expliquée", "Variance cumulée"),
       col = c("blue", "red"), pch = 19, lty = 1)
```


```{r, fig.width=10, fig.height=8}
# Question 8 
# Créer le biplot avec des couleurs et des tailles ajustées
biplot(res, scale = 0, 
       main = "Biplot des projections des pays et des variables",
       cex = 0.8,  # Taille des points et flèches
       col = c("blue", "red"))  # Points des pays en bleu, flèches des variables en rouge
```


```{r, fig.width=8, fig.height=10}
# Question 9 Observez d’autres plans factoriels, et commentez.
# Plan PC2 vs PC3
biplot(res, choices = c(2, 3), scale = 0, 
       main = "Biplot des projections des pays et des variables (PC2 vs PC3)",
       cex = 0.8,  # Taille des points et flèches
       col = c("blue", "red"))  # Points des pays en bleu, flèches des variables en rouge

# Plan PC3 vs PC4
biplot(res, choices = c(3, 4), scale = 0, 
       main = "Biplot des projections des pays et des variables (PC3 vs PC4)",
       cex = 0.8,  # Taille des points et flèches
       col = c("blue", "red"))  # Points des pays en bleu, flèches des variables en rouge
```


```{r, fig.width=8, fig.height=10}

# Question 10. Déterminez quelles sont les variables les mieux représentées par le premier plan factoriel
# Extraire les charges des vecteurs propres (coefficients de res$rotation)
loadings <- res$rotation

# Calculer le cos² pour le plan PC1-PC2
cos2_PC1_PC2 <- rowSums(loadings[, 1:2]^2)  # Somme des carrés des charges sur PC1 et PC2

# Afficher les cos²
cat("Cos² des variables sur le plan PC1-PC2 :\n")
print(round(cos2_PC1_PC2, 2))

# Identifier les variables les mieux représentées
best_variables <- names(sort(cos2_PC1_PC2, decreasing = TRUE))
cat("\nVariables les mieux représentées par PC1-PC2 (par ordre de qualité) :\n")
print(best_variables)
```





```{r, fig.width=10, fig.height=7}
# Question 11
# Étape 1 : Extraire les scores des individus
scores <- res$x  # Les coordonnées des individus dans le nouvel espace

# Étape 2 : Extraire les variances des composantes principales
variances <- res$sdev^2  # Valeurs propres

# Étape 3 : Calculer les contributions des individus sur chaque composante
# Contribution = (scores^2) / (variance de la composante)
contributions <- sweep(scores^2, 2, variances, "/")

# Étape 4 : Résumé des contributions
cat("Contributions des individus sur chaque composante principale :\n")
print(round(contributions, 2))  # Contributions arrondies

# Étape 5 : Calcul des contributions totales par individu (somme sur toutes les composantes)
contributions_totales <- rowSums(contributions)
cat("\nContributions totales par individu :\n")
print(round(contributions_totales, 2))

# Étape 6 : Identifier les individus avec des contributions faibles
seuil <- 1 / nrow(scores)  # Seuil théorique de contribution moyenne
individus_faibles <- names(contributions_totales[contributions_totales < seuil])
cat("\nIndividus ayant une contribution faible (en dessous du seuil) :\n")
print(individus_faibles)
```


```{r, fig.width=14, fig.height=10}
# question 12 
# Étape 1 : Extraire les scores
coord <- res$x  # Scores des individus

# Étape 2 : Ajouter les noms des pays
tmp <- read.csv("data/euro.csv", header = TRUE, sep = ";")  # Charger les noms
rownames(coord) <- tmp[, 1]

# Étape 3 : Créer le graphique
plot(coord[, 1], coord[, 2], 
     xlab = "PC1 (Composante principale 1)", 
     ylab = "PC2 (Composante principale 2)", 
     main = "Projection des individus sur le plan PC1-PC2", 
     pch = 20, col = "blue")

# Ajouter les noms des individus
text(coord[, 1], coord[, 2], labels = rownames(coord), pos = 4, cex = 0.8)
```


```{r, fig.width=12, fig.height=10}
# TP2 ****************
```





```{r, fig.width=10, fig.height=10}
# Question 1  
#  Après avoir déterminé les deux matrices de dissimilarités en utilisant respectivement une métrique Euclidienne
# et une métrique réduite, effectuez une classification ascendante hiérarchique des données fondée pour chaque
# matrice sur le saut minimum.
# Matrice de dissimilarité Euclidienne (non normalisée)
dissimilarity_euclidean <- as.matrix(dist(euro_data, method = "euclidean"))

# Normaliser les données
euro_data_normalized <- scale(euro_data)

# Matrice de dissimilarité Euclidienne (normalisée)
dissimilarity_reduced <- as.matrix(dist(euro_data_normalized, method = "euclidean"))

# Afficher les matrices
cat("Matrice de dissimilarité Euclidienne (non normalisée) :\n")
print(round(dissimilarity_euclidean, 2))

cat("\nMatrice de dissimilarité Euclidienne (normalisée) :\n")
print(round(dissimilarity_reduced, 2))


```


```{r, fig.width=14, fig.height=10}
# Question 1 suite 
# CAH avec la matrice non normalisée
cah_single_euclidean <- hclust(dist(euro_data, method = "euclidean"), method = "single")

# CAH avec la matrice normalisée
cah_single_reduced <- hclust(dist(euro_data_normalized, method = "euclidean"), method = "single")

# Dendrogramme pour les données non normalisées
plot(cah_single_euclidean, 
     main = "Dendrogramme (Euclidienne, non normalisée)", 
     xlab = "Pays", sub = "", cex = 0.8)

# Dendrogramme pour les données normalisées
plot(cah_single_reduced, 
     main = "Dendrogramme (Euclidienne, normalisée)", 
     xlab = "Pays", sub = "", cex = 0.8)


```


```{r}
# Question 2 
# Récupérer les hauteurs des fusions
heights_euclidean <- sort(cah_single_euclidean$height, decreasing = TRUE)
heights_reduced <- sort(cah_single_reduced$height, decreasing = TRUE)

# Courbe des hauteurs pour la matrice non normalisée
plot(1:length(heights_euclidean), heights_euclidean, 
     type = "b", col = "blue", pch = 20,
     xlab = "Nombre de classes", 
     ylab = "Hauteur", 
     main = "Hauteur en fonction du nombre de classes (Euclidienne, non normalisée)")

# Courbe des hauteurs pour la matrice normalisée
plot(1:length(heights_reduced), heights_reduced, 
     type = "b", col = "red", pch = 20,
     xlab = "Nombre de classes", 
     ylab = "Hauteur", 
     main = "Hauteur en fonction du nombre de classes (Euclidienne, normalisée)")


```


```{r}
# Question 3 
# Fixer le nombre de classes (par exemple 4, basé sur la question 2)
k <- 4  # Ajuster selon la coupure choisie
classes <- cutree(cah_single_reduced, k = k)

# Ajouter les classes aux données
euro_data_with_classes <- data.frame(euro_data_normalized, Classe = classes)
# Fonction pour calculer le centre de gravité
calculate_center <- function(data, classes) {
  aggregate(. ~ Classe, data = data, FUN = mean)
}

# Centres de gravité
centers <- calculate_center(euro_data_with_classes, classes)
cat("Centres de gravité :\n")
print(centers)
```


```{r, fig.width=14, fig.height=10}
# Calculer l'inertie intra-classe
# Question 3 suite 
calculate_inertia <- function(data, centers, classes) {
  inertia <- 0
  for (class in unique(classes)) {
    class_data <- data[classes == class, ]
    class_center <- centers[class, -ncol(centers)]  # Exclure la colonne des classes
    inertia <- inertia + sum(rowSums((class_data - class_center)^2))
  }
  return(inertia)
}

# Inertie totale
inertia <- calculate_inertia(euro_data_normalized, centers, classes)
cat("\nInertie intra-classe totale : ", round(inertia, 2), "\n")
```


```{r, fig.width=14, fig.height=10}
# Question 4 
# Classification ascendante hiérarchique avec le critère de Ward
cah_ward <- hclust(dist(euro_data_normalized, method = "euclidean"), method = "ward.D2")

# Représenter le dendrogramme
plot(cah_ward, 
     main = "Dendrogramme (Critère de Ward, Euclidienne, normalisée)", 
     xlab = "Pays", sub = "", cex = 0.8)
par(mfrow = c(1, 2))  # Afficher les deux dendrogrammes côte à côte

# Dendrogramme avec le saut minimum
plot(cah_single_reduced, 
     main = "Dendrogramme (Saut minimum)", 
     xlab = "Pays", sub = "", cex = 0.8)

# Dendrogramme avec Ward
plot(cah_ward, 
     main = "Dendrogramme (Critère de Ward)", 
     xlab = "Pays", sub = "", cex = 0.8)

par(mfrow = c(1, 1))  # Réinitialiser l'affichage


```


```{r}
# Qustion 4  Effectuez une autre classification en utilisant le critère de Ward. Commentez les différences de résultats.
# Découpage en classes avec les deux méthodes
classes_single <- cutree(cah_single_reduced, k = 4)
classes_ward <- cutree(cah_ward, k = 4)

# Ajouter les classes aux données
euro_data_with_classes <- data.frame(euro_data_normalized, Classe_Single = classes_single, Classe_Ward = classes_ward)

# Afficher un aperçu
head(euro_data_with_classes)
```


```{r}
# Fixer le nombre de classes
# question 5 
# Vérifier les NA ou NaN dans les données normalisées
cat("Y a-t-il des NA/NaN dans les données ?\n")
print(any(is.na(euro_data_normalized)))

# Si des NA sont présents, afficher leur localisation
if (any(is.na(euro_data_normalized))) {
  cat("Position des NA/NaN :\n")
  print(which(is.na(euro_data_normalized), arr.ind = TRUE))
  euro_data_normalized <- apply(euro_data_normalized, 2, function(x) {
  ifelse(is.na(x), mean(x, na.rm = TRUE), x)
})
print(any(is.na(euro_data_normalized)))
}
```


```{r}
euro_data_normalized <- apply(euro_data_normalized, 2, function(x) {
  ifelse(is.na(x), mean(x, na.rm = TRUE), x)
})
print(any(is.na(euro_data_normalized)))
```


```{r}
# Suite question 5 
# Fixer le nombre de classes
k <- 4

# Appliquer k-means
set.seed(42)  # Fixer la graine pour rendre les résultats reproductibles
kmeans_result <- kmeans(euro_data_normalized, centers = k, nstart = 10)

# Afficher les résultats
cat("Classes affectées par k-means :\n")
print(kmeans_result$cluster)

cat("\nCentres des classes :\n")
print(round(kmeans_result$centers, 2))

cat("\nInertie intra-classe totale :\n")
print(round(kmeans_result$tot.withinss, 2))
```


```{r}
# Initialiser les variables
max_k <- 10  # Tester jusqu'à 10 classes
inertie_totale <- sum(scale(euro_data_normalized, center = TRUE, scale = FALSE)^2)
inertie_intra <- numeric(max_k)
inertie_expliquee <- numeric(max_k)

# Calculer l'inertie intra-classe pour chaque k
for (k in 1:max_k) {
  set.seed(42)  # Graine pour reproductibilité
  kmeans_result <- kmeans(euro_data_normalized, centers = k, nstart = 10)
  inertie_intra[k] <- kmeans_result$tot.withinss
  inertie_expliquee[k] <- 1 - (inertie_intra[k] / inertie_totale)
}

# Tracer la courbe
plot(1:max_k, inertie_expliquee, type = "b", pch = 20, col = "blue",
     xlab = "Nombre de classes (k)", ylab = "Inertie expliquée (%)",
     main = "Inertie expliquée en fonction du nombre de classes")

```





```{r}
# Question 7 
# Étape 1 : Effectuer l'ACP
# Effectuer l'ACP sur les données normalisées
res_acp <- prcomp(euro_data_normalized, center = TRUE, scale. = TRUE)

# Résumé de l'ACP pour comprendre les variances expliquées
cat("Résumé de l'ACP :\n")
print(summary(res_acp))

# Étape 2 : Récupérer les résultats de classification
# Fixer le nombre de classes optimal
k <- 4  # Ajuster selon les résultats précédents

# Classes obtenues par CAH
classes_cah <- cutree(cah_single_reduced, k = k)

# Classes obtenues par k-means
classes_kmeans <- kmeans_result$cluster

# Étape 3 : Représenter les classes dans le plan factoriel
par(mfrow = c(1, 2))  # Afficher les deux graphiques côte à côte

# Représentation des classes CAH
plot(res_acp$x[, 1], res_acp$x[, 2], 
     col = classes_cah, 
     pch = 20, 
     xlab = "PC1", ylab = "PC2",
     main = "Plan factoriel avec classes CAH")

# Représentation des classes k-means
plot(res_acp$x[, 1], res_acp$x[, 2], 
     col = classes_kmeans, 
     pch = 20, 
     xlab = "PC1", ylab = "PC2",
     main = "Plan factoriel avec classes k-means")

par(mfrow = c(1, 1))  # Réinitialiser l'affichage


```



```{r}
# Étape 1 : Effectuer l'ACP
# Effectuer l'ACP sur les données normalisées
res_acp <- prcomp(euro_data_normalized, center = TRUE, scale. = TRUE)

# Résumé de l'ACP pour comprendre les variances expliquées
cat("Résumé de l'ACP :\n")
print(summary(res_acp))

# Étape 2 : Récupérer les classes des deux méthodes
# Fixer le nombre optimal de classes (par exemple, k = 4)
k <- 4

# Classes obtenues par CAH
classes_cah <- cutree(cah_single_reduced, k = k)

# Classes obtenues par k-means
classes_kmeans <- kmeans_result$cluster

# Étape 3 : Ajouter les classes au tableau des coordonnées de l'ACP
coord_acp <- data.frame(res_acp$x[, 1:2], Classe_CAH = as.factor(classes_cah), Classe_Kmeans = as.factor(classes_kmeans))

# Étape 4 : Représenter les classes dans le plan factoriel
par(mfrow = c(1, 2))  # Afficher les deux graphiques côte à côte

# Représentation des classes CAH
plot(coord_acp$PC1, coord_acp$PC2, 
     col = coord_acp$Classe_CAH, 
     pch = 20, 
     xlab = "PC1", ylab = "PC2",
     main = "Plan factoriel avec classes CAH")

# Représentation des classes k-means
plot(coord_acp$PC1, coord_acp$PC2, 
     col = coord_acp$Classe_Kmeans, 
     pch = 20, 
     xlab = "PC1", ylab = "PC2",
     main = "Plan factoriel avec classes k-means")

par(mfrow = c(1, 1))  # Réinitialiser l'affichage

```





```{r}
# Étape 1 : Définir une zone restreinte dans le plan factoriel
zone_restante <- coord_acp[coord_acp$PC1 > -1 & coord_acp$PC1 < 1 & coord_acp$PC2 > -1 & coord_acp$PC2 < 1, ]

# Afficher les pays dans la zone restreinte
cat("Pays dans la zone sélectionnée :\n")
print(zone_restante)

# Étape 2 : Représenter graphiquement la zone
plot(zone_restante$PC1, zone_restante$PC2, 
     col = zone_restante$Classe_CAH, 
     pch = 20, 
     xlab = "PC1", ylab = "PC2",
     main = "Zone restreinte avec classes CAH")

# Ajouter les noms des pays
text(zone_restante$PC1, zone_restante$PC2, labels = rownames(zone_restante), pos = 4, cex = 0.8)

```
```{r}
tinytex::is_tinytex()

```


Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
